# 옵셔널 체이닝
- obj?.prop – obj가 존재하면 obj.prop을 반환하고, 그렇지 않으면 undefined를 반환함
- obj?.[prop] – obj가 존재하면 obj[prop]을 반환하고, 그렇지 않으면 undefined를 반환함
- obj?.method() – obj가 존재하면 obj.method()를 호출하고, 그렇지 않으면 undefined를 반환함
```js
let user = {}; // 주소 정보가 없는 사용자
alert( user && user.address && user.address.street ); // undefined, 에러가 발생하지 않습니다.
alert( user?.address?.street ); // null이나 undefined인 경우 평가를 멈추고 undefined 반환. 에러가 발생하지 않습니다.
```
- ?.(), ?.[]
```js
let user1 = {
  firstName: "Violet",
  admin() {
    alert("관리자 계정입니다.");
  }
}

let user2 = null;

user1.admin?.(); // 관리자 계정입니다.
user2.admin?.();

let key = "firstName";
alert( user1?.[key] ); // Violet
alert( user2?.[key] ); // undefined
alert( user1?.[key]?.something?.not?.existing); // undefined

delete user?.name; // user가 존재하면 user.name을 삭제합니다.
// 쓰기는 에러, user?.name = "Violet";, 에러가 발생하는 이유는 undefined = "Violet"이 되기 때문
```

# 심볼형
- 객체 프로퍼티 키로 오직 문자형과 심볼형만을 허용
- Symbol은 자동 형 변환 되지 않습니다.
```js
// id는 새로운 심볼이 됩니다.
let id = Symbol();
let id = Symbol("id");
alert(id1 == id2); // false

alert(id.toString()); // Symbol(id)가 얼럿 창에 출력됨
alert(id.description); // id

user[id] = 1;
alert( user[id] ); // 심볼을 키로 사용해 데이터에 접근할 수 있습니다.

let user = {
  name: "John",
  [id]: 123 // "id": 123은 안됨
};

for (let key in user) alert(key); // name만 출력되고, 심볼은 출력되지 않습니다.
alert( "직접 접근한 값: " + user[id] ); // 심볼로 직접 접근하면 잘 작동합니다.

let clone = Object.assign({}, user); // Object.assign은 키가 심볼인 프로퍼티를 배제하지 않고 객체 내 모든 프로퍼티를 복사
alert( clone[id] ); // 123

// 전역 레지스트리에서 심볼을 읽습니다.
let id = Symbol.for("id"); // 심볼이 존재하지 않으면 새로운 심볼을 만듭니다.
let idAgain = Symbol.for("id");
alert( id === idAgain ); // true
alert( Symbol.keyFor(idAgain) ); // id

let globalSymbol = Symbol.for("name");
let localSymbol = Symbol("name");
alert( Symbol.keyFor(globalSymbol) ); // name, 전역 심볼
alert( Symbol.keyFor(localSymbol) ); // undefined, 전역 심볼이 아님
alert( localSymbol.description ); // name
```
- Symbol.hasInstance
- Symbol.isConcatSpreadable
- Symbol.iterator
- Symbol.toPrimitive
- 기타 등등

# 원시형
- obj1 + obj2 => 자동 형 변환